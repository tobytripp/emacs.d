#+SETUPFILE: ~/.emacs.d/org-init/level-0.orgsetup
* Clojure Customizations

** DONE Clojure + Cider Keybindings of Interest

   | Key-Chord | Command                           |
   | C-c C-x   | Reload the current namespace      |
   | C-c ,     | Run the current namespace's tests |
   | C-c M-,   | Run one test                      |
   | C-c C-,   | Re-run last test                  |
   | C-c C-e   | Eval and print last s-exp         |

** Cider

   Set-up some local key-bindings.  This will pull in =clojure-mode= as well.
   #+BEGIN_SRC emacs-lisp
     (require-package 'clojure-mode)
     (autoload 'clojure-mode "clojure-mode" "Major mode for clojure")

     (eval-after-load 'clojure-mode
       '(progn
          (require-package 'cider)))

     (eval-after-load 'cider
       '(progn
          (require-package 'cider-eval-sexp-fu)
          (require 'cider-eval-sexp-fu)
          (define-key cider-mode-map (kbd "<f3>")    'cider-eval-defun-at-point)
          (define-key cider-mode-map (kbd "<f5>")    'toby/save-and-eval-buffer)
          (define-key cider-mode-map (kbd "<f12>")   'cider-test-run-tests)
          (define-key cider-mode-map (kbd "C-c C-e") 'cider-eval-print-last-sexp)
          (setq cider-mode-line '(:eval "üç∫"))))

     (add-hook 'cider-mode-hook      #'eldoc-mode)
     (add-hook 'cider-mode-hook      #'paredit-mode)
     (add-hook 'cider-repl-mode-hook #'paredit-mode)
     (add-hook 'cider-repl-mode-hook #'subword-mode)

     (defun toby/save-and-eval-buffer ()
       "Save open buffers and send the current buffer to the active Cider session."
       (interactive)
       (save-some-buffers 't)
       (cider-eval-buffer))
   #+END_SRC

** Clojure

   Paredit is my best-est friend
   #+BEGIN_SRC emacs-lisp
     (require-package 'clj-refactor)
     (autoload 'clj-refactor "clj-refactor-mode")

     (defun toby/clojure-init ()
       (paredit-mode 1)
       (show-paren-mode 1)

       (clj-refactor-mode 1)
       (yas-minor-mode 1)

       (cljr-add-keybindings-with-prefix "C-c c")

       ;; Compojure Macros:
       (define-clojure-indent
         (defroutes 'defun)
         (defspec 'defun)
         (GET 2)
         (POST 2)
         (PUT 2)
         (DELETE 2)
         (HEAD 2)
         (ANY 2)
         (context 2)))

     (defun toby/lisp-keys ()
       (define-key clojure-mode-map (kbd "<C-down>") 'forward-sexp)
       (define-key clojure-mode-map (kbd "<C-up>")   'backward-sexp))

     (eval-after-load 'clojure-mode '(toby/lisp-keys))

     (add-hook 'clojure-mode-hook 'toby/clojure-init)
     (toby/defhook cider-mode-hook (paredit-mode))
   #+END_SRC

*** Clojuredocs

    #+BEGIN_SRC emacs-lisp
      (defconst clojuredocs-url "http://clojuredocs.org/")

      (defun clojuredocs-url (ns name)
        "Generate a clojuredocs search"
        (let ((base-url clojuredocs-url))
          (when (and name ns)
            (concat base-url ns "/" name))))

      (defun toby/clojuredocs-lookup (symbol)
        "Open the clojuredocs.org documentation for SYMBOL"
        (if-let ((var-info (cider-var-info symbol)))
            (let ((name (nrepl-dict-get var-info "name"))
                  (ns (nrepl-dict-get var-info "ns")))
              (browse-url (clojuredocs-url ns name)))
          (error "Symbol %s not resolved" symbol)))

      (defun toby/clojuredocs-web (&optional arg)
        "Open clojuredocs.org in the default web browser.

         Prompts for the symbol to look-up, or uses the symbol at point."
        (interactive "P")
        (funcall (cider-prompt-for-symbol-function arg)
                 "Clojuredoc for"
                 #'toby/clojuredocs-lookup))

      (define-key clojure-mode-map (kbd "C-c C-d o") 'toby/clojuredocs-web)
    #+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(provide 'clojure)
#+END_SRC
