#+SETUPFILE: ~/.emacs.d/org-init/level-0.orgsetup
#+TITLE: Shell Settings
* EShell
  EShell is a shell written in elisp.  This makes it both less
  capable than other terminal emulators and also gives it some
  interesting features.

** Opening EShells
   First, a short-cut to quickly open a shell.  Repeated invocations
   will bring back the same shell so we don't end up with a bunch of
   them running about.
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x m") 'eshell)
   #+END_SRC

   It's nice to have an easy short-cut to launch into a shell in the
   current buffer's directory.  We'll start with a function to launch it:
   #+BEGIN_SRC emacs-lisp
     (defun toby/eshell-in-buffer-dir ()
       "Open eshell in the current buffer's directory"
       (interactive)
       (let ((dir default-directory))
         (let ((b (get-buffer eshell-buffer-name)))
           (unless b (eshell)))
         (display-buffer eshell-buffer-name t)
         (switch-to-buffer-other-window eshell-buffer-name)
         (end-of-buffer)
         (unless (equalp dir default-directory)
           (cd dir)
           (eshell-send-input)
           (end-of-buffer))))
   #+END_SRC

   and a binding to launch it:
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x C-m") 'toby/eshell-in-buffer-dir)
   #+END_SRC

   Sometimes what you want is a real terminal:
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x M") 'multi-term)
   #+END_SRC

   One great feature of Eshell is its ability to call Emacs functions
   as though they were shell commands.  Here we'll define an alias
   =ff= that will open a file from the Eshell command line into an
   Emacs buffer:
   #+BEGIN_SRC emacs-lisp
     (add-hook 'eshell-mode-hook
               (lambda ()
                 (defalias 'ff 'find-file)))
   #+END_SRC


* Comint Mode

  Adjust some =comint= parameters (the mode that handles terminal buffers).
  =comint-mode= is the parent mode of many shell modes.

  #+BEGIN_SRC emacs-lisp
    (setq comint-buffer-maximum-size 10240)
    (add-hook 'comint-output-filter-functions 'comint-truncate-buffer)
    (add-hook 'comint-output-filter-functions 'comint-watch-for-password-prompt)
  #+END_SRC

  Let's add a function to easily clear an active shell buffer:
  #+BEGIN_SRC emacs-lisp
    (defun clear-shell ()
      "Clear the current shell buffer"
      (interactive)
      (let ((comint-buffer-maximum-size 0))
        (comint-truncate-buffer)))
  #+END_SRC

  Binding =s-k= to =kill-buffer= doesn't make sense to me.
  #+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "s-k"))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (defun set-my-shell-bindings ()
      (interactive)
      (local-set-key (kbd "<up>")   'comint-previous-input)
      (local-set-key (kbd "<down>") 'comint-next-input)
      (local-set-key (kbd "s-k")    'clear-shell))

    (add-hook 'shell-mode-hook 'set-my-shell-bindings)
    (add-hook 'eshell-mode-hook 'set-my-shell-bindings)
  #+END_SRC

* Other Shells

  Sometimes, to get proper shell colors in emacs, updating terminfo
  can be required:

  #+BEGIN_SRC sh
  tic -o ~/.terminfo /usr/local/Cellar/emacs/current/share/emacs/24.3/etc/e/eterm-color.ti
  #+END_SRC

  Set up the =multi-term= package and term mode hooks:

  #+BEGIN_SRC emacs-lisp
    (require-package 'multi-term)
    (setq multi-term-program "/bin/zsh")

    (defun toby/term-hook ()
      (linum-mode -1)
      (setq show-trailing-whitespace nil)
      ;; yas mode can break the TAB character in terminals
      (yas-minor-mode -1))

    (add-hook 'term-mode-hook 'toby/term-hook)
  #+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
  (provide 'eshell-hooks)
#+END_SRC
