#+SETUPFILE: ~/.emacs.d/org-init/level-0.orgsetup
#+TITLE: Shell Settings
* EShell
  EShell is a shell written in elisp.  This makes it both less
  capable than other terminal emulators and also gives it some
  interesting features.

** Opening EShells
   First, a short-cut to quickly open a shell.  Repeated invocations
   will bring back the same shell so we don't end up with a bunch of
   them runningn about.
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x m") 'eshell)
   #+END_SRC

   It's nice to have an easy short-cut to launch into a shell in the
   current buffer's directory.  We'll start with a function to launch it:
   #+BEGIN_SRC emacs-lisp
     (defun toby/eshell-in-buffer-dir ()
       "Open eshell in the current buffer's directory"
       (interactive)
       (let ((dir default-directory))
         (let ((b (get-buffer eshell-buffer-name)))
           (unless b (eshell)))
         (display-buffer eshell-buffer-name t)
         (switch-to-buffer-other-window eshell-buffer-name)
         (end-of-buffer)
         (unless (equalp dir default-directory)
           (cd dir)
           (eshell-send-input)
           (end-of-buffer))))
   #+END_SRC

   and a binding to launch it:
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x C-m") 'toby/eshell-in-buffer-dir)
   #+END_SRC

   Sometimes what you want /is/ another shell instance:
   #+BEGIN_SRC emacs-lisp
    ;; Start a new eshell even if one is active.
     (global-set-key (kbd "C-x M") (lambda () (interactive) (eshell t)))
   #+END_SRC

   One great feature of Eshell is its ability to call Emacs functions
   as though they were shell commands.  Here we'll define an alias
   =ff= that will open a file from the Eshell command line into an
   Emacs buffer:
   #+BEGIN_SRC emacs-lisp
     (add-hook 'eshell-mode-hook
               (lambda ()
                 (defalias 'ff 'find-file)))
   #+END_SRC

   Adjust some =comint= parameters (the mode that handles terminal buffers).

   Multi-term is an extension for running multiple native shells within Emacs:
   #+BEGIN_SRC emacs-lisp
     (require-package 'multi-term)
     (setq multi-term-program "/bin/bash -l")
   #+END_SRC

* Comint Mode
  =comint-mode= is the parent mode of many shell modes.

  #+BEGIN_SRC emacs-lisp
    (setq comint-buffer-maximum-size 10240)
    (add-hook 'comint-output-filter-functions 'comint-truncate-buffer)
    (add-hook 'comint-output-filter-functions 'comint-watch-for-password-prompt)
  #+END_SRC

  Let's add a function to easily clear an active shell buffer:
  #+BEGIN_SRC emacs-lisp
    (defun clear-shell ()
      "Clear the current shell buffer"
      (interactive)
      (let ((comint-buffer-maximum-size 0))
        (comint-truncate-buffer)))
  #+END_SRC

  Binding =s-k= to =kill-buffer= doesn't make sense to me.
  #+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "s-k"))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (defun set-my-shell-bindings ()
      (interactive)
      (local-set-key (kbd "<up>")   'comint-previous-input)
      (local-set-key (kbd "<down>") 'comint-next-input)
      (local-set-key (kbd "s-k")    'clear-shell))

    (add-hook 'shell-mode-hook 'set-my-shell-bindings)
    (add-hook 'eshell-mode-hook 'set-my-shell-bindings)
  #+END_SRC

* Other Shells

  #+BEGIN_SRC emacs-lisp
    (require-package 'multi-term)
    (setq multi-term-program "/bin/zsh")

    (defun toby/term-hook ()
                (setq show-trailing-whitespace nil)
                (yas-minor-mode -1))

    (add-hook 'term-mode-hook 'toby/term-hook)
  #+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
  (provide 'eshell-hooks)
#+END_SRC
